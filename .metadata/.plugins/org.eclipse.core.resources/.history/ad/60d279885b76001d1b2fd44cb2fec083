package hw4;

import java.util.Random;
import api.MazeMap;
import api.Mode;
import api.Location;
import api.Actor;
import api.Descriptor;

import api.Descriptor;
import api.Direction;
import api.MazeCell;
import static api.Direction.RIGHT;
import static api.Direction.UP;
import static api.Direction.LEFT;
import static api.Direction.DOWN;

public abstract class SuperClass implements Actor{
	protected static final double ERR = 0.001; //Margin of error for comparing exact coordinates to the center of a cell
	// SPEED
	protected double baseIncrement;
	protected double currentSpeed; 
	protected double currentIncrement;


	protected MazeMap maze; // A read-only representation of the maze for detecting walls and edges
	protected Location scatterTarget; // The scatter location for scatter mode
	protected Location home;
	protected Location currentLocation; // The current location 
	protected Location nextLocation;
	protected Descriptor currentDesc;
	protected double colExact;
	protected double rowExact;
	protected double turnTarget;

	//DIRECTIONS
	protected Direction currentDirection; // Current Direction
	protected Direction nextDirection; // The Next Direction
	protected Direction homeDirection;
	protected Direction previousDirection;
	
	private Mode currentMode; // The Current Mode
	protected boolean turning;
	
	/**
	 * Constructor for SuperClass for Player Initialization Parameters
	 * @param maze
	 * @param home
	 * @param baseSpeed
	 * @param homeDirection
	 */
	SuperClass(MazeMap maze, Location home, double baseSpeed, Direction homeDirection) {
		this.maze = maze;
		this.home = home;
		this.baseIncrement = baseSpeed;
		this.currentIncrement = baseSpeed;
		this.homeDirection = homeDirection;
	}
	/**
	 * Constructor for SuperClass for Ghost Initialization Parameters
	 * @param maze
	 * @param home
	 * @param baseSpeed
	 * @param homeDirection
	 * @param scatterTarget
	 * @param rand
	 */
	SuperClass(MazeMap maze, Location home, double baseSpeed, Direction homeDirection, Location scatterTarget, Random rand) {
		this.baseIncrement = baseSpeed;
		this.maze = maze;
		this.currentDirection = homeDirection;
		this.home = home;
		this.scatterTarget = scatterTarget;
		this.currentIncrement = baseSpeed;
		this.homeDirection = homeDirection;
	}

	// ABSTRACT ABSTRACT ABSTRACT ABSTRACT 

	public void reset() {
		setMode(Mode.INACTIVE, null);
		currentSpeed = this.baseIncrement;
		setDirection(this.getHomeDirection());
		currentLocation = home;
	}

	public double getCurrentIncrement() {
		return baseIncrement;
	}


	public abstract void calculateNextCell(Descriptor d);


	public Direction getHomeDirection() {
		// Gets the direction of the ghost's home location from the current location
		Location currentLoc = new Location((int) getRowExact(), (int) getColExact()) ;
		Location homeLoc = getHomeLocation();
		if (currentLoc.row() > homeLoc.row()) {
			return UP;
		}
		else if (currentLoc.row() < homeLoc.row()) {
			return DOWN;
		}
		else if (currentLoc.col() > homeLoc.col()) {
			return LEFT;
		}
		else {
			return RIGHT;
		}	
	}


	public void update(Descriptor description) {
		// Given a descriptor, update the state of the ghost
		// Add or subtract the ghost's current increment from the ghost's exact location using the current direction
		if (this.getCurrentDirection() == null){
			return;
		}		
		double increment = getCurrentIncrement();
		double curColExact = getColExact();
		double curRowExact = getRowExact();
		int rowNum = (int) curRowExact;
		int colNum = (int) curColExact;

		// get the distance to the center of the cell 
		double distanceToCenter = distanceToCenter();

		//using current direction switch statement to update the exact location
		switch (getCurrentDirection()) {
			case LEFT:
				// tunnel special case
				if(curColExact - increment - 0.5 < 0) {
					curColExact = maze.getNumColumns() + (curColExact - increment - 0.5);
				}else{
					if(distanceToCenter > -ERR && distanceToCenter < increment && maze.isWall(rowNum,  colNum - 1)) {
						increment = distanceToCenter;
					}
					curColExact -= increment;
				}
				break;
			
			case RIGHT: 
				//special case for tunnel 
				if(curRowExact + increment + 0.5 > maze.getNumRows()) {
					curRowExact = (curRowExact + increment + 0.5) - maze.getNumRows();
				}else{
					if(distanceToCenter > -ERR && distanceToCenter < increment && maze.isWall(rowNum,  colNum + 1)) {
						increment = distanceToCenter;
					}
					curRowExact += increment;
				}
				break;
			case UP:
				if(distanceToCenter > -ERR && distanceToCenter < increment && maze.isWall(rowNum - 1,  colNum)) {
					increment = distanceToCenter;
				}
				curRowExact -= increment;
				break;
			case DOWN:
				if(distanceToCenter > -ERR && distanceToCenter < increment && maze.isWall(rowNum + 1,  colNum)) {
					increment = distanceToCenter;
				}
				curRowExact += increment;
				break;
			}
			setRowExact(curRowExact);
			setColExact(curColExact);
	}


	public double getBaseIncrement() {
		return baseIncrement;
	}


	/**
	 * MODE MODE MODE MODE MODE
	 */
	public void setMode(Mode gMode, Descriptor Description) {
		//		return new Descriptor(playerLoc, playerDir, enemyLoc)
		this.currentMode = gMode;
		if(Description != null) {
			calculateNextCell(Description);
		}

		// Adjust the ghost speed according to the mode
		if (gMode == Mode.FRIGHTENED) {
			this.currentSpeed = baseIncrement * (2.0/3.0);
		}else if(gMode == Mode.DEAD) {
			this.currentSpeed = baseIncrement * (2.0);
		}else {
			this.currentSpeed = baseIncrement;
		}
	}
	public Mode getMode() {
		return this.currentMode;
	}

	/**
	 * DIRECTION DIRECTION DIRECTION DIRECTION
	 */
	public void setDirection(Direction dir) {
		currentDirection = dir;
	}
	public Direction getCurrentDirection() {
		return currentDirection;
	}

	/**
	 * LOCATION LOCATION LOCATION LOCATION
	 */
	public Location getCurrentLocation() {
		return currentLocation;
	}
	public Location getHomeLocation() {
		return home;
	}


	/**
	 * EXACT EXACT EXACT EXACT 
	 */
	public void setColExact(double c) {
		colExact = c;
	}
	public void setRowExact(double r) {
		rowExact = r;
	}
	public double getColExact() {
		return colExact;
	} 
	public double getRowExact() {
		return rowExact;
	}


	public Location getNextCell() {
		this.calculateNextCell(currentDesc);
		return nextLocation;
	}


	/**
	 * When turning, we need to update along the previous direction
	 * of travel until lined up with the new row or column.
	 */
	protected void handleTurn() {
		double increment = getCurrentIncrement();
		double currentRowExact = getRowExact();
		double currentColumnExact = getColExact();

		if (this.previousDirection == UP) {
			double distanceToTravel = this.getRowExact() - this.turnTarget;
			if (increment >= distanceToTravel - ERR) {
				increment = distanceToTravel;
				//Reached the center!
				turning = false;
			}
			currentRowExact -= increment;
		}else if (this.previousDirection == DOWN) {
			double distanceToTravel = turnTarget - currentRowExact;
			if (increment >= distanceToTravel - ERR) {
				increment = distanceToTravel;
				turning = false;
			}
			currentRowExact += increment;
		}else if(this.previousDirection == LEFT) {
			double distanceToTravel = currentColumnExact - turnTarget;
			if(increment >= distanceToTravel - ERR) {
				increment = distanceToTravel;
				turning = false;
			}
			currentColumnExact -= increment;
		}else if(this.previousDirection == RIGHT) {
			double distanceToTravel = turnTarget - currentColumnExact;
			if(increment >= distanceToTravel - ERR) {
				increment = distanceToTravel;
				turning = false;
			}
			currentColumnExact += increment;
		}
		this.setColExact(currentColumnExact);
		this.setColExact(currentColumnExact);
	}
	/**
	 * Determines the distance to the center of the cell through the 
	 * difference between the current position and the center of the 
	 * current cell
	 * @return
	 */
	protected double distanceToCenter() {
		double columnPosition = getColExact();
		double rowPosition = getRowExact();
		switch(this.getCurrentDirection()) {
			case LEFT: 
				return columnPosition - ((int) columnPosition)- 0.5;
			case RIGHT: 
				return 0.5 - (columnPosition - ((int) columnPosition));
			case UP: 
				return rowPosition - ((int) rowPosition) - 0.5;
			case DOWN: 
				return 0.5 - (rowPosition - ((int) rowPosition));
		}
		return 0;
	}
}
